#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass jpconf
\begin_preamble
%\renewcommand{\maketitle}{}
\newcommand{\maketitle}{}

\AtBeginDocument{
       \let\oldmarginpar\marginpar
    % TO hide margin notes in the final:
     %\renewcommand\marginpar[1]{}
     \renewcommand\marginpar[1]{{\oldmarginpar[#1]{\color{red}\tiny{#1}}}}

}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package babel
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Keyword Search over Data Service Integration for Accurate Results
\end_layout

\begin_layout Author
Vidmantas Zemleris
\begin_inset ERT
status open

\begin_layout Plain Layout

$^1$
\end_layout

\end_inset

, Valentin Y Kuznetsov
\begin_inset ERT
status open

\begin_layout Plain Layout

$^2$
\end_layout

\end_inset

 and Peter Kreuzer
\begin_inset ERT
status open

\begin_layout Plain Layout

$^3$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
address{$^1$Faculty of Mathematics and Informatics, Vilnius University,
 Lithuania}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Digital Science and Computing Center, 
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
address{$^2$Cornell University, USA}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
address{$^3$Rheinisch-Westfaelische Tech.
 Hoch., Germany}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ead{$^1$vidmantas.zemleris@cern.ch}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Virtual data integration aims at providing a coherent interface for querying
 heterogeneous data sources (e.g., web services, web forms, proprietary systems)
 with minimum upfront integration effort.
 Data is usually accessed through structured queries, such as SQL, requiring
 to learn the language and to get acquainted with data organization, which
 may pose problems even to proficient users.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Limited access to data instances as well as users’ concern with accurate
 results of arbitrary queries present additional challenges to traditional
 approaches (such as query forms, information retrieval, keyword search
 over relational databases) making them not applicable.
\end_layout

\end_inset

We present a keyword search system, which proposes a ranked list of structured
 queries along with their explanations.
 It operates mainly on the metadata, such as the constraints on inputs accepted
 by services.
 It was developed as an integral part of the CMS data discovery service,
 and is currently available as open source.
\end_layout

\begin_layout Abstract
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unlike previous implementations, the system is freely available and makes
 no assumptions about the input query, while maintaining its ability to
 leverage the query’s structural patterns - in case they exist.
 The system is discussed in the context of CMS data discovery service where
 the simplicity and capabilities of the search interface play a crucial
 role in the ability of its users to satisfy their information needs.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard

\emph on
Virtual Data Integration
\emph default
\lang british
 (VDI) is an approach of 
\lang english
“integrating data from multiple sources without having to first load data
 into a central warehouse”
\begin_inset CommandInset citation
LatexCommand citep
after "page 1"
key "eii_2005"

\end_inset


\lang british
.
 Instead, data physically stays at its origin, and is requested on demand.
 A VDI system parses and transforms the query, sends it to services and
 performs a number of transformations on the results such as elimination
 of inconsistencies in data formats, entity naming.
 
\begin_inset Marginal
status open

\begin_layout Plain Layout

\color blue
\lang british
Unfortunately
\color inherit
/
\end_layout

\end_inset

Still, that forces its users 
\lang english
to learn the query language and to get acquainted with data organization
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 (i.e.
 the mediated schema)
\end_layout

\end_inset

, which is often not straight-forward
\color blue
 when where is no direct access to the data
\color inherit
 at 
\color blue
the data-services
\color inherit
.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Even worse, the data services may provide only limited black-box-like interfaces
 without direct access to inspect their contents
\end_layout

\end_inset


\lang british

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
is the most beneficial when other data
\color blue
 
\color inherit
integration techniques are not applicable
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang british
for instance, publish-subscribe approach is not applicable in the presence
 of proprietary (and reluctant to change) systems, data-warehousing is too
 heavy and complex then large portions of data are volatile or when only
 limited interfaces are provided by proprietary services.
\end_layout

\end_inset

.
 
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
Among the alternatives to structured queries are: 1) interfaces based on
 regular forms
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout

\lang british
?
\end_layout

\end_inset

, that are impractical for complex queries over large number of entities/attribu
tes; 2) the keyword search based on metadata returning query results directly,
 risking that the query interpretation chosen is not the correct one, as
 the keyword queries are ambiguous; or 3) the keyword search based on metadata
 and proposing a list of structured queries for user to choose from.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
Virtual integration presents an additional challenge, since only limited
 access to the data instances is available, rendering the traditional keyword
 search methods that return data-tuples
\series bold
 
\series default
inapplicable (e.g.
 Information Retrieval or Keyword search over relational databases).
\end_layout

\end_inset

In this work, we explore the keyword search, as a more intuitive alternative
 to writing structured queries from scratch.
 This subject in fact, received relatively little attention in the field
 of data integration
\begin_inset CommandInset citation
LatexCommand citep
key "nl_to_dataservices_guerrisi2012natural"

\end_inset

.
 
\end_layout

\begin_layout Standard

\color red
\lang british
\begin_inset Marginal
status open

\begin_layout Plain Layout

\color red
\lang british
TODO! 
\series bold
contextualization!
\end_layout

\end_inset


\color inherit
Keyword queries are 
\lang english
ambiguous
\lang british
 and often underspecified
\begin_inset CommandInset citation
LatexCommand citep
key "Kws_metadata_2011"

\end_inset


\lang english
, thus the standard approach is to produce a ranked list of most-likely
 structured query suggestions
\begin_inset CommandInset citation
LatexCommand citep
key "ethz2012,keymantic10,bergamaschi2011hidden"

\end_inset

.
 As
\lang british
 queries over data-services can be quite expensive to execute, we display
 a list of query suggestions to the user before actually evaluating them.

\color red
 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
\lang british
Second, even if keyword queries do not have clear syntactic structure, keywords
 referring to related concepts usually come close to each other in the query
 
\begin_inset CommandInset citation
LatexCommand citep
key "characterization_search_behaviour_kumar2009,Kws_metadata_2011"

\end_inset

, which can be used to improve the quality of suggestions.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang british
Second, the average query length continues to increase, which shows that
 users are moving towards preference of expressing their information need
 in natural languages than just typing keywords.
 
\begin_inset Quotes eld
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang british
http://searchuserinterfaces.com/book/sui_ch12_emerging.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang british
The system presented was developed at the CMS Experiment, CERN as part of
 a data discovery/integration system called 
\begin_inset Quotes eld
\end_inset

CMS Data Aggregation System
\begin_inset Quotes erd
\end_inset


\emph on
, (DAS
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "DAS"
description "CMS Data Aggregation System - The EII system used at CMS"

\end_inset


\emph default
)
\begin_inset CommandInset citation
LatexCommand citep
key "Kuznetsov2010,Kuznetsov2011"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
and covers some specific use-cases
\end_layout

\end_inset

, which is released as open source.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
Building on the experience gained while working on an EII system
\series bold
 
\series default
at the 
\emph on
CMS Experiment
\emph default

\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "CMS"
description "The Compact Moun Selenoid Experiment at the European Organization for Nuclear Research (CERN)"

\end_inset

 at 
\emph on
CERN
\emph default
, 
\color red
we will focus on the implementation of keyword search, also touching and
 the mechanisms for user feedback and some
\series bold
 
\series default
more distant topics such as usability and performance of an EII.
\end_layout

\end_inset

DAS has no predefined schema, thus only minimal mappings are needed to describe
 the differences among the services.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
It uses the 
\emph on
Boolean Retrieval Model
\emph default
 as users are often interested in retrieving ALL the items matching their
 query.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
The queries are executed either from web browser or through a command line
 interface (feeding the results into users' applications).
 
\end_layout

\end_inset


\series bold

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series bold
\lang british
Query language (DASQL) and its execution
\end_layout

\end_inset


\series default
It
\emph on
 
\emph default
uses simple structured queries
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
 eliminating the inconsistencies in entity naming, data formats and combining
 the results
\end_layout

\end_inset

 which are formed specifying an entity to be retrieved and some selection
 criteria
\begin_inset Foot
status open

\begin_layout Plain Layout

\lang british
passed as input to the services, including the virtual ones which abstract
 or combine physical data services
\end_layout

\end_inset

.
 The results could be further filtered, sorted or aggregated.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
, e.g.: 
\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Graphics
	filename /home/vidma/DAS_paper/figures/DASQL_1avg_problem_statement.pdf
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
As seen above, DASQL closely corresponds to the physical execution flow
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang british
 over the EII
\end_layout

\end_inset

: based on the requested entity and the conditions on service inputs, DAS
 decides the set of services to be queried
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang british
including pre-defined 
\begin_inset Quotes eld
\end_inset

virtual services
\begin_inset Quotes erd
\end_inset

, which feed results from one service into inputs of the others
\end_layout

\end_inset

.
 Then, after retrieving, processing and merging the results from services,
 the filters and projections, and aggregators are applied.
\color magenta

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\color magenta
\lang british
In between there could be additional operations, such as 
\emph on
unique
\emph default
 for selecting only unique records, or custom map-reduce processing steps.
 
\end_layout

\end_inset


\color inherit
 Finally, the results are cached for subsequent uses.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mappings keywords into structured query suggestions
\end_layout

\begin_layout Subsubsection*
Problem definition
\end_layout

\begin_layout Standard

\lang british
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status collapsed

\begin_layout Plain Layout

\lang british
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-40pt}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Graphics
	filename /home/vidma/DAS_paper/figures/problem_statement_das_service_ex.pdf
	lyxscale 30
	width 50text%

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-20pt}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout

\lang british
a data-service (simplified)
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset

Given a keyword query, KWQ
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "KWQ"
description "keyword query\\\\"

\end_inset

=
\begin_inset Formula $\left(kw_{1},kw_{2},..,kw_{n}\right)$
\end_inset

, we are interested in translating it into a ranked list of best matching
 structured queries.
 We are given this metadata:
\end_layout

\begin_layout Itemize

\emph on
\lang british
schema
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "schema"
description "by schema we refer to the integration schema (virtual schema based of entities exposed by the services)"

\end_inset

 terms
\emph default

\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "schema terms"
description "names of entities in integration schema and their attributes (names of either inputs to the services or their output fields)"

\end_inset

: entities and their attributes (
\emph on
inputs
\emph default
 to the services or their 
\emph on
output
\emph default
 fields)
\end_layout

\begin_layout Itemize

\emph on
\lang british
value terms
\emph default

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
(domain vocabulary)
\end_layout

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "value terms"
description "values of entity attributes (that could be input parameters of data services, or be contained in their results)"

\end_inset

: for some fields a list of values, but for most only 
\emph on

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
the
\emph on
 service mappings
\emph default
 define the
\emph on
 
\end_layout

\end_inset

constraints
\emph default
 on data-service inputs (mandatory inputs, regular expressions defining
 values accepted).
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
Consider these queries: 
\begin_inset Quotes eld
\end_inset


\emph on
what is the average
\color red
 
\color inherit
size of RelVal datasets where number of events is more than 1000
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
avg dataset size Zmmg number of events>1000
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\emph on
avg(dataset size) Zmmg `number of events'>1000
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Plain Layout

\lang british
In the particular case of DASQL, used at CMS Experiment, the input has to
 be mapped into:
\end_layout

\begin_layout Itemize

\lang british
type of result (e.g.
 datasets) and projections of fields in the service outputs
\end_layout

\begin_layout Itemize

\lang british
conditions passed as service inputs, e.g.
 datset=*RelVal*
\end_layout

\begin_layout Itemize

\lang british
post-filters on service outputs: e.g.
 dataset.nevents > 1000 
\end_layout

\begin_layout Itemize

\lang british
basic aggregation functions, applied on service results: e.g.

\color blue
 
\color inherit
avg(dataset.size)
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
In this work, we consider as potential results only the 
\emph on
conjunctive queries
\emph default
 augmented with simple aggregation functions without grouping (that correspond
 to select-project[-join
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang british
the 
\begin_inset Quotes eld
\end_inset

joins
\begin_inset Quotes erd
\end_inset

 are currently limited, and can not be explicitly specified by the user
\end_layout

\end_inset

] in SQL, with selections composed only of conjunctions) as potential results.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\lang british
Overview of our implementation
\end_layout

\begin_layout Standard

\lang british
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "45text%"
status open

\begin_layout Plain Layout

\lang british
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-40pt}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\lang british
\begin_inset Graphics
	filename figures/kws_architecture.pdf
	lyxscale 40
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-10pt}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Caption

\begin_layout Plain Layout

\lang british
Keyword query processing
\begin_inset CommandInset label
LatexCommand label
name "fig:query-translation-steps"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-10pt}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
 Taking inspiration from Keymantic 
\begin_inset CommandInset citation
LatexCommand citep
key "keymantic10"

\end_inset

, a keyword query is processed as follows (see Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:query-translation-steps"

\end_inset

).
 
\end_layout

\end_inset

 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
When designing the system we were focusing on its simplicity, ranking quality
 and robustness (queries can be full sentence, plain keywords, or contain
 structural patterns).
\end_layout

\end_inset

Firstly, the query is 
\emph on
tokenized
\emph default
 cleaning up the query and identifying any explicit quoted phrase tokens,
 operators
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
 (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Tokenizer"

\end_inset

)
\end_layout

\end_inset

, or other structural patterns
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
 to improve the quality of suggestions
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\lang british
Then, employing a number of entity matching techniques, the 
\begin_inset Quotes eld
\end_inset


\emph on
entry points
\emph default

\begin_inset Quotes erd
\end_inset

 are identified: for each keyword, we obtain a listing of schema and value
\series bold
 
\series default
terms it may correspond to along with a rough estimate of the likelihood
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Matching-keywords"

\end_inset

)
\end_layout

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang british
This includes identifying keyword chunks corresponding to multi-word terms:
 many of them are unclean, machine-readable field-names, with irrelevant
 and frequent terms, motivating the use of IDF-based
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "IDF"
description "Inverse Document Frequency, used to downrank frequent and therefore likely irrelevant terms"

\end_inset

 information retrieval techniques.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang british
Lastly, different permutations of 
\emph on
entry points
\emph default
 are evaluated combining the scores of individual keywords and applying
 
\color blue
the
\series bold
 
\series default
contextual rules
\color inherit
 to boost scores of 
\emph on
query interpretations
\emph default
 that 
\begin_inset Quotes eld
\end_inset

respect
\begin_inset Quotes erd
\end_inset

 the likely dependencies between the nearby keywords.
 During the same step, the 
\emph on
interpretations
\emph default
 not compatible with the data integration system are filtered out.
 
\color blue
Then these are interpreted as structured queries, disambiguating the keyword
 matchings between: result types, projections, selections (filters on service
 inputs or outputs), or some simple operators.
\end_layout

\begin_layout Standard

\emph on
\lang british
Example.

\emph default
 Consider this query
\color blue
:
\family typewriter
\size footnotesize
\color inherit
 
\emph on
RelVal `number of events > 1000
\emph default
'.
 
\family default
\size default
Tokenizer would return these tokens: 
\family typewriter
\size footnotesize
\emph on
`RelVal'; `number of events>1000'
\family default
\size default
\emph default
.
 Then, each token result in some entry points:
\color magenta
 
\family typewriter
\size footnotesize
\color inherit

\begin_inset Newline newline
\end_inset


\emph on
'RelVal'
\family default
 →
\family typewriter
 (1.0, input-value: group=RelVal)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

'RelVal'
\family default
 →
\family typewriter
 (0.7, input-value: dataset=*RelVal*)
\emph default

\begin_inset Newline newline
\end_inset


\emph on

\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

'number of events>100'
\family default
 →
\family typewriter
 (0.93, output-filter: dataset.nevents>100)
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

'number of events>100'
\family default
 →
\family typewriter
 (0.93, output-filter: file.nevents>100
\size scriptsize
\emph default
)
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
definecolor{grey_dark}{rgb}{0.7, 0.7, 0.7}{
\backslash
color{grey_dark}and more with lower scores...}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang british
\begin_inset Wrap figure
lines 0
placement r
overhang 0.5cm
width "45text%"
status open

\begin_layout Plain Layout

\lang british
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-0.8cm}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\lang british
\begin_inset Graphics
	filename figures/ui_larger.png
	lyxscale 40
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vspace{-10pt}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Caption

\begin_layout Plain Layout

\lang british
Results - query suggestions
\begin_inset CommandInset label
LatexCommand label
name "fig:query-results"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-10pt}
\end_layout

\end_inset


\end_layout

\end_inset

It can be seen that the 
\emph on
`RelVal'
\emph default
 keyword is ambiguous
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
, there is a `RelVal' group, and also `RelVal' could be part of dataset
 name.
 While,
\end_layout

\end_inset

 , while 
\emph on
`number of events'
\emph default
 could be attribute of 
\emph on
dataset, file
\emph default
 or 
\emph on
block
\emph default
.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
Also well there is some ambiguity in chunking, 'dataset sizes' may map to
 
\emph on
dataset.size
\emph default
 attribute, while dataset is also the entity type.
\end_layout

\end_inset

Combining the entry point scores yields the shown results in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:query-results"

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Subsection

\lang british
Step 1: Tokenizer
\begin_inset CommandInset label
LatexCommand label
name "sub:Tokenizer"

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
First the keyword query is cleaned-up, standardizing its notation (e.g.
 removing extra spaces, normalizing date formats, and recognizing some expressio
ns in
\color red
 
\color inherit
natural language such as simple operators [X equals Y, X more than Y, etc]).
 This is accomplished using a number of regular expression replacement patterns.
 
\end_layout

\begin_layout Plain Layout

\lang british
Then, the keyword query is tokenized into tokens of:
\end_layout

\begin_layout Itemize

\lang british
strings of "terms operator value" (e.g.
 
\family typewriter
nevent > 1, 
\begin_inset Quotes eld
\end_inset

number of events
\begin_inset Quotes erd
\end_inset

=100, 
\begin_inset Quotes eld
\end_inset

number of events>=100
\begin_inset Quotes erd
\end_inset


\family default
), if any
\end_layout

\begin_layout Itemize

\lang british
phrases s in brackets (e.g.

\family typewriter
 "number of events"
\family default
), if any
\end_layout

\begin_layout Itemize

\lang british
individual query terms, otherwise
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scoring individual keywords
\lang british
 (step 2)
\begin_inset CommandInset label
LatexCommand label
name "sub:Matching-keywords"

\end_inset


\end_layout

\begin_layout Paragraph*

\lang british
\begin_inset Note Note
status collapsed

\begin_layout Paragraph*

\lang british
Matching multi-word schema terms
\end_layout

\begin_layout Plain Layout

\lang british
This component identifies keyword chunks corresponding to 
\emph on
multi-word
\emph default
 
\emph on
schema-terms
\emph default
 representing field-names or titles of service results fields.
 The fields in service results are quite specific: some may have only the
 machine-readable field-names and no human readable description, and may
 contain some frequent and not so informative terms.
 All this motivates the use of IDF-based
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "IDF"
description "Inverse Document Frequency, used to downrank frequent and therefore likely irrelevant terms"

\end_inset

 information retrieval techniques.
 In addition, the field names in service outputs (which are processed artefacts
 of JSON or XML responses) have some parent-child structure which may provide
 useful contextual information (e.g.
 block.replica.creation_time vs block.creation_time).
\end_layout

\begin_layout Plain Layout

\series bold
\color magenta
\lang british
\begin_inset Marginal
status open

\begin_layout Plain Layout

\series bold
\color magenta
\lang british
TODO: mention paper from XML retrieval
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
For simplicity, we used an existing IR library, Whoosh
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang british
Even if Apache 
\emph on
Lucene
\emph default
 is assumed as the most mature of the open-source libraries, it requires
 Java and has large footprint.
 Even if that may impact the results slightly, we use 
\emph on
whoosh,
\emph default
 a python library which has no dependencies.
\end_layout

\end_inset

, where we store 
\begin_inset Quotes eld
\end_inset

documents
\begin_inset Quotes erd
\end_inset

 each representing 
\begin_inset Quotes eld
\end_inset

a field in service outputs
\begin_inset Quotes erd
\end_inset


\series bold
\color cyan
 
\series default
\color inherit
(that is a field of an entity in integration schema).
 Each such 
\emph on
document
\emph default
 consists of multiple 
\emph on
fields
\emph default
, with different weights of importance assigned to each:
\end_layout

\begin_layout Itemize

\lang british
fully-qualified machine readable field-name (e.g.
 block.replica.creation_time)
\end_layout

\begin_deeper
\begin_layout Itemize

\lang british
a field containing a tokenized+stemmed version of machine readable field-name
 (e.g.
 creation_time)
\end_layout

\begin_layout Itemize

\lang british
context - a field containing a tokenized+stemmed version of machine readable
 field-name's parent (block.replica)
\end_layout

\end_deeper
\begin_layout Itemize

\lang british
human readable field title, if any (e.g.
 
\begin_inset Quotes eld
\end_inset

Creation time of block's replica
\begin_inset Quotes erd
\end_inset

, but often this do not include the context: 
\begin_inset Quotes eld
\end_inset

Creation time
\begin_inset Quotes erd
\end_inset

, or it does not exist)
\series bold
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
only tokenized+stemmed version --- it seems creating multiple versions of
 same fields decrease performance with default params; therefore I even
 got rid of copies including the stop-words
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang british
To find the matches, we query the IR library, both for phrase and single
 term matches of up to the k-nearby keywords (we use maximum of 4, which
 both provides sufficient context, and is short enough to be computationally
 inexpensive), phrase matches given larger weight.
 
\end_layout

\begin_layout Plain Layout

\lang british
The ranking is done using BM25F scoring function.
 After filtering out the worst results these will become the entry points
 for mapping keywords into the fields of data service outputs.
 Currently we directly use the score returned by the IR library
\color red

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\color red
\lang british
[TF_IDF scoring is currently used.
 BM25F also available, however with default parameters it performed worse
 with unclean documents: multiple copies of same words in 
\begin_inset Quotes eld
\end_inset

fake
\begin_inset Quotes erd
\end_inset

 fields, some terms have ambiguous naming (titles), others have only 
\begin_inset Quotes eld
\end_inset

machine readable
\begin_inset Quotes erd
\end_inset

 field names]
\end_layout

\end_inset


\color inherit
manually normalized between [0..1]
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout

\lang british
normalization: threshold based on weights signifying a good score + (maybe
 smoothing function)
\end_layout

\end_inset

.
 The scoring could be improved tuning the scoring function, but in our case
 it works already not so bad.
\end_layout

\begin_layout Plain Layout

\lang british
Finally, the same functionality could be also achieved through retrieving
 a list of matching fields for each keyword separately and then combining
 them through the scoring function, however the earlier approach allows
 pruning out the worst scoring token pairs and supporting the phrase search
 more easily.
 In either case, the problem of how to incorporate the IDFs and context
 information remains.
\color magenta

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\color magenta
\lang british
TECHNICAL NOTES FOR MYSELF: CAVEATS AND TODOs TO CONSIDER:
\end_layout

\begin_layout Itemize

\color magenta
\lang british
full field match [all tokens] is much better even than phrase match: 
\begin_inset Quotes eld
\end_inset

number of events
\begin_inset Quotes erd
\end_inset

 vs 
\begin_inset Quotes eld
\end_inset

events; number; block
\begin_inset Quotes erd
\end_inset

 [idf shall penalize this, but this seems not enough] - (how about modified
 document length in BM25F?)
\end_layout

\begin_deeper
\begin_layout Itemize

\color cyan
\lang british
how about to force BM25F to count only distinct tokens once? e.g.
 tf(d, t)c = max(w_c), regardless of field c
\end_layout

\end_deeper
\begin_layout Itemize

\color magenta
\lang british
multiple matches of same term result in unfair scores
\end_layout

\begin_deeper
\begin_layout Itemize

\color magenta
\lang british
e.g.
 number -> run 
\series bold
number, 
\series default
where
\series bold
 
\series default
number
\series bold
 
\series default
is repeated run.run_number, tokenized: 'run; number', title: 'run number'
\end_layout

\begin_layout Itemize

\color magenta
\lang british
idf shall be stronger than physical term count
\end_layout

\begin_layout Itemize

\color magenta
\lang british
as mentioned in a paper on 
\begin_inset Quotes eld
\end_inset

Semantic Search with BM25F
\begin_inset Quotes erd
\end_inset

 which criticized Lucene ranking, naive inclusion of multiple fields could
 lead to false high-matches.
 
\emph on
~approx:~Matching terms on different fields would be scored higher than
 matches of the same keywords in the same field, which is semantically better
 defined~~.
\end_layout

\end_deeper
\begin_layout Itemize

\color cyan
\lang british
Far future: using context information without enforcing that to belong only
 to that field (we already use result type = result entity type)
\end_layout

\end_inset


\color inherit

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\color red
\lang british
Matching keyword into an sample of values (guessing which is the best attribute
 without having all of its values)
\end_layout

\end_inset


\end_layout

\end_inset

Matching the value terms
\series bold
\color red

\begin_inset Marginal
status open

\begin_layout Plain Layout

\series bold
\color red
\lang british
shorten down!
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang british
DAS mappings contain regular expressions (regexp) that describe the input
\emph on
 
\emph default
values accepted by services.
 As some of regexp's could be loosely defined, this can result in false
 positives, thus, the regexp matches are scored lower than others, distinguishin
g different levels of regexp's accuracy.
 For some schema terms, a list of possible values, that were obtained by
 bootstrapping them through respective data service interfaces.
 Different cases of matches are distinguished: full match, partial match,
 and matches of keywords containing wildcards (in order of decreasing score).
 If a value matches a regexp, but is not contained in the known values list
 and the values listing of the given field is considered to be changing
 not often, we exclude this very likely false match to reduce the false
 positives\SpecialChar \@.

\end_layout

\begin_layout Paragraph*

\color blue
\lang british
Matching the schema terms: TODO
\end_layout

\begin_layout Standard

\lang british
This also includes identifying keyword chunks corresponding to multi-word
 terms (output fields in service results): many of them are unclean, machine-rea
dable field-names, with irrelevant and frequent terms, motivating the use
 of IDF-based
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "IDF"
description "Inverse Document Frequency, used to downrank frequent and therefore likely irrelevant terms"

\end_inset

 information retrieval techniques.
\end_layout

\begin_layout Subsection

\lang british
The ranker and scoring functions
\begin_inset CommandInset label
LatexCommand label
name "sub:Ranking-function"

\end_inset

 (step 3)
\end_layout

\begin_layout Standard

\lang british
As the last step, different combinations of the entry points have to be
 explored combining the scores of individual keywords in some way (e.g.
 summing of log likelihoods, averaging, described below).
\lang english

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The scoring functions 
\begin_inset CommandInset label
LatexCommand label
name "sub:Scoring-functions-used"

\end_inset


\end_layout

\end_inset

 We experimented with two scoring functions: 1) first one averaging the
 scores, as used by Keymantic
\begin_inset CommandInset citation
LatexCommand citep
key "keymantic10"

\end_inset

, and 2) summing the log likelihoods which is closer to probabilistic [
\series bold
thinking]
\series default
.
 In the beginning two methods
\series bold
 
\series default
seemed to perform almost equally well
\series bold
,
\series default
 with the probabilistic approach being more sensitive to 
\series bold
inaccuracies
\series default
 in scoring of the entry points, but it became clearly better than 
\emph on
averaging
\emph default
 when entry points accuracy was slightly improved
\begin_inset Foot
status open

\begin_layout Plain Layout

\color blue
the scores are just estimates of our confidence, not real probabilities;
 the results improved with improvements to accuracy of string matching functions
 and removed the unreliable semantic matching
\end_layout

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The final scores of the probabilistic approach are also more complex to
 interpret (we would like to present the user with color coding which identifies
 the our confidence, and the scores if exponented vary much more than in
 averaging).
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection

\lang british
Setting the scoring parameters
\end_layout

\begin_layout Plain Layout

\lang british
First the individual system components has been tuned to a 
\begin_inset Quotes eld
\end_inset

sufficient
\begin_inset Quotes erd
\end_inset

 level using a number of unit tests, and manual testing.
 In some cases it required assigning arbitrary estimates likelihood/confidence.
\end_layout

\begin_layout Plain Layout

\lang british
Then using a number of keyword queries either written by the end users of
 the system, or the developer to address 
\series bold
marginal/specific
\series default
 use cases, a number of global system parameters had been fine-tuned by
 hand: weights for regexps, not taking a keyword, multi-word matching.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang british
packages, tool-kits: uncertainties, nltk, wordnet,mongodb
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
score\_avg(tags|KWQ)=\frac{{\displaystyle \sum_{i=1}^{|KWQ|}{\displaystyle \left(score_{tag_{i}|kw_{i}}+{\displaystyle \sum_{h_{j}\in H}h_{j}(tag_{i}|kw_{i};tag_{i-1,..,1})}\right)}}}{N\_non\_stopword}
\end{equation}

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-1cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
score\_prob(tags|KWQ)=\sum_{i=1}^{|KWQ|}\left({\displaystyle {\displaystyle \log}\left(score_{tag_{i}|kw_{i}}\right)}+\sum_{h_{j}\in H}h_{j}(tag_{i}|kw_{i};tag_{i-1,..,1})\right)
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\emph on
Notation:
\emph default
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $score_{tag_{i}|kw_{i}}$
\end_inset

 is the likelihood of matching an individual keyword 
\begin_inset Formula $kw_{i}$
\end_inset

 as 
\begin_inset Formula $tag_{i}$
\end_inset

 (an entry point); 
\begin_inset Formula $h_{j}(tag_{i}|kw_{i};tag_{i-1,..,1})$
\end_inset

 denotes the score boost returned by contextualization heuristic 
\begin_inset Formula $h_{j}$
\end_inset

 given a concrete tagging so far (or last few tags).
 T
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
he
\series bold
\emph on
 
\series default
probabilistic
\series bold
 
\series default
\emph default
approach uses a set of 
\begin_inset Quotes eld
\end_inset

fake
\begin_inset Quotes erd
\end_inset

 tags with predefined scores: unmapped, unmapped stop word.
\end_layout

\begin_layout Paragraph*

\color red
Heuristics and contextual rules in ranking.
\end_layout

\begin_layout Standard
As part of entry points:
\end_layout

\begin_layout Itemize

\lang british
balance between taking the keyword or leaving it out (the one that we are
 unsure about) 
\begin_inset Marginal
status open

\begin_layout Plain Layout

\series bold
\color magenta
\lang british
Keymantic assumed all keyword have interpretation!
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\lang british
rare use-cases: prevent schema terms to be mapped to values with high score,
 as this is unlikely (e.g.
 dataset names include 'dataset')
\end_layout

\begin_layout Itemize

\color black
\lang british
boost important keywords (different parts of speech are of different importance,
 e.g.
 stop-words are less useful than nouns
\color blue
)
\begin_inset Marginal
status open

\begin_layout Plain Layout

\color magenta
\lang british
only stop-words are distinguished now; '(tell|show|display|find) me?' filtered
 out by tokenizer
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Contextualization rules:
\end_layout

\begin_layout Itemize

\lang british
promoting such combinations where nearby keywords refer to related schema
 terms (e.g.
 entity name and it's value)
\end_layout

\begin_layout Subsection

\lang british
Miscellanea
\end_layout

\begin_layout Paragraph

\lang british
Automatically identifying the qualities of data services
\end_layout

\begin_layout Standard

\lang british
The data integration system, DAS, uses only minimal mappings - they describe
 services, their input parameters, and mappings between inconsistently named
 output fields.
 Any other information, such as the complete listing of fields in the service
 outputs, or their types are identified by processing results of historical
 queries.
 To get satisfactory coverage immediately, a list of bootstrapping queries
 is used to initialize the most important field and value listings.
\color red

\begin_inset Note Note
status open

\begin_layout Plain Layout

\color red
\lang british
In future we may also the data types (string, integer) as hints for scoring
 ambiguous predicate predicate tokens (e.g.
 event number>10).
\end_layout

\end_inset


\color inherit

\begin_inset Note Note
status collapsed

\begin_layout Paragraph

\lang british
Performance
\end_layout

\begin_layout Plain Layout

\lang british
At the CMS collaboration, implementing additional optimizations is not of
 a highest priority, as with the current implementation, the queries runs
 faster than in a second (the time needed to run the queries in average
 is 0.2s, with the maximum of 1s
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang british
measured on an 4 years old laptop with 1.7Ghz processor and 4GB of RAM; server
 hardware is much more powerful; 
\end_layout

\end_inset

), while for most of the queries the EII system requires tens of seconds
 to minutes to retrieve the actual query results from the data services.
 
\end_layout

\begin_layout Plain Layout

\lang british
Still a number of methods are available for improving the performance (e.g.
 bipartite matching problem approached with the top-k results version of
 Hungarian-Munkres algorithm
\begin_inset CommandInset citation
LatexCommand citep
key "keymantic10"

\end_inset

, or dynamic programming with assumption of short maximum length of keyword
 dependences) in exchange for additional complexity of the implementation
 or the additional assumptions.
\end_layout

\begin_layout Plain Layout

\lang british
---------------------
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsubsection*
The heuristics and pruning out the unacceptable candidates
\end_layout

\begin_layout Itemize

\lang british
Relationships between keywords:
\end_layout

\begin_layout Itemize

\lang british
Qualities of Data Integration System:
\end_layout

\begin_deeper
\begin_layout Itemize

\lang british
promote data service inputs over filters on their results: 1) it is more
 efficient, especially when this is possible; 2) there are much more of
 possible entities to filter, so more false matches are expected there,
 while the service inputs shall cover large part of cases
\end_layout

\begin_layout Itemize

\series bold
\lang british
if some keyword can be matched as the requested entity, and mapping of other
 keywords fits the service constraints
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout

\series bold
\color cyan
\lang british
shall we allow both as filter name and result type? no?
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\lang british
if requested entity and a filter condition is the same (a small increase,
 a common use-case is retrieving an entity given it's 
\begin_inset Quotes eld
\end_inset

primary key
\begin_inset Quotes erd
\end_inset

 identifier or a wild-card)
\end_layout

\begin_layout Itemize

\lang british
for being able to execute the query, the service constraints must be satisfied;
 still it could useful to the interpretations that achieve high rank, even
 if they do not satisfy some constraint (e.g.
 a mandatory filter is missing) informing the user
\begin_inset Marginal
status open

\begin_layout Plain Layout

\color magenta
\lang british
not yet implemented
\end_layout

\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There was also an attempt towards answering open-domain natural language
 queries over data-services, however this is further from out topic .
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
\lang british
Keymantic
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "keymantic_kws_metadata_bergamaschi2011,keymantic10"

\end_inset

 answers keyword queries over relational databases with limited access to
 the data instances or over data integration 
\begin_inset CommandInset citation
LatexCommand citep
key "keymantic10"

\end_inset

.
 First, based on meta-data
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang british
in EII, only limited access to data instances is available, therefore instead
 of just indexing the all data, the meta-data shall be used
\end_layout

\end_inset

, individual keywords are scored as potential matches to 
\emph on
schema terms
\emph default
 (entity names and their attributes, using some entity matching techniques)
 or as potential 
\emph on
value
\emph default
 matches (by checking any available constraints, such as the regular expressions
 imposed by the database or data-services).
 Then, these scores are combined
\series bold
, 
\series default
and refined by heuristics that increase the scores of query interpretations
 with the nearby keywords having related labels assigned.
 Finally, these labels are interpreted as SQL queries.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang british
We present a case study of Data Integration Systems at the CMS Collaboration,
 CERN, including performance analysis, usability and other aspects.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\lang british
\begin_inset Marginal
status open

\begin_layout Plain Layout

\series bold
\color red
\lang british
TODO:
\series default
 introduce the paper; add motivation: usefulness of KWS/NLs, contradicting
 results; lack of research in the field of KW/NL Search over Web Services;
 needs of CMS.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
Also some of the data may be changing often, services have limitations on
 their interfaces, and users are interested in complete and up-to-date answers
 (i.e.
 Boolean Retrieval), the problem of keyword search becomes more complex
 as it is hard or even impossible to materialize/index all the contents
 in one central place.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\series bold
\color red
\lang british
TODO
\series default
: present the problem in general, setting at CMS and our solution
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\color red
\lang british
TODO: add a motivating example in the beginning!
\end_layout

\begin_layout Plain Layout

\color red
\lang british
Major problems:
\end_layout

\begin_layout Itemize

\lang british
what is more suitable for querying information: keywords, full sentence,
 or restricted structured language
\end_layout

\begin_layout Itemize

\lang british
keyword search is too much ambiguous (for searching structured data)
\end_layout

\begin_layout Itemize

\lang british
full sentences are long to write, and often hard to process as there are
 many ways of expressing same idea
\end_layout

\begin_layout Itemize

\lang british
structured language must be learned, including schema terms and its 
\begin_inset Quotes eld
\end_inset

grammar
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subparagraph

\lang british
Intro, Usability issues
\end_layout

\begin_layout Plain Layout

\lang british
TODO: discuss differences between Structured, Keyword and NL Search
\end_layout

\begin_layout Plain Layout

\lang british
refer to Paper...
\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang british
There exist a number of ways for expressing user's information need, some
 being more natural for users, but harder to interpret for a machine (e.g.
 natural language (NL) or keyword queries), structured query or through
 any other interfaces such as predefined Query Forms.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\lang british
Communicating User's Intent
\end_layout

\begin_layout Plain Layout

\lang british
Deciding on what is the best suited for 
\series bold
communicating user's intent
\series default
 is a problem, where recent studies reported disagreement in their results.
 Some users prefer writing queries as complete sentences that is more natural
 
\begin_inset CommandInset citation
LatexCommand citep
key "2011natural,ethz_kaufmann2007nl_int"

\end_inset

 than the faster to type keyword queries, which on the other hand are even
 more ambiguous.
 Others prefer the structured languages that are 
\series bold
the easiest
\series default
 to process by a machine, but incurs a steeper learning curve (as the correspond
ing grammar and the lexicon has to be learned).
\end_layout

\begin_layout Plain Layout

\lang british
[XYZ] pointed out that 
\color magenta

\begin_inset Quotes eld
\end_inset

the research suggests people prefer to state their information need rather
 than use keywords.
 But after first using a search engine they quickly learned that full questions
 resulted in failure.
\begin_inset Quotes erd
\end_inset

 http://people.ischool.berkeley.edu/~hearst/talks/upitt.pdf
\end_layout

\begin_layout Plain Layout

\lang british
\begin_inset Note Note
status collapsed

\begin_layout Subsubsection

\lang british
Semantic Web Services
\end_layout

\begin_layout Plain Layout

\lang british
Having detailed semantic Web Service descriptions would help interpreting
 more complex queries (in example of CMS Experiment, such as 'smallest 
\series bold
file
\series default
 in /SingleElectron/Run2011A-WElectron-*/RAW-RECO with 
\series bold
number 
\bar under
of events
\series default
\bar default
 between 100 and 1000', where 'number of events' is actually referring to
 an attribute 
\emph on
nevents
\emph default
 of a file (file.nevents).
\end_layout

\begin_layout Plain Layout

\color magenta
\lang british
Domain ontology is needed
\end_layout

\begin_layout Plain Layout

\lang british
There is a number of technologies that allow data and service providers
 to describe semantically services their services and resources, such as
 the 
\begin_inset Quotes eld
\end_inset

Simple Semantic Web Architecture and Protocol
\begin_inset Quotes erd
\end_inset

 (SSWAP) that uses third-party ontologies.
\end_layout

\begin_layout Plain Layout

\lang british
Gessler DDG, Schiltz GS, May GD, Avraham S, Town CD, Grant D, Nelson RT:
 SSWAP: A Simple Semantic Web Architecture and Protocol for semantic web
 services.
 BMC Bioinformatics 2009, 10:309.
\end_layout

\begin_layout Plain Layout

\color magenta
\lang british
In this work, we assume that the extensive service semantic descriptions
 are already existing, or are not needed, and focus on the process of translatio
n between keyword queries and the structured ones.
\end_layout

\begin_layout Plain Layout

\lang british
http://www.jbiomedsem.com/content/pdf/2041-1480-2-8.pdf
\end_layout

\end_inset


\end_layout

\end_inset


\series bold
\color cyan

\begin_inset Marginal
status collapsed

\begin_layout Plain Layout

\series bold
\color cyan
\lang british
Note: Their assumptions: 
\series default

\begin_inset Quotes eld
\end_inset

keyword can be mapped to only one database term; no two keywords can be
 mapped into the same database term 
\series bold
[how about multi-keyword-terms?]
\series default
.
 
\series bold
every keyword plays some role in the query, i.e., there are no unjustiﬁed
 keywords (!)
\series default

\begin_inset Quotes erd
\end_inset

 
\series bold
\color red
it seems it was summing the scores (no log()!) Weighted-bipartite matching
 as optimization; still exponencial because of first step?
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
\lang british
KEYRY
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "bergamaschi2011hidden"

\end_inset

 attempts to incorporate users feedback through training an Hidden Markov
 Model's (HMM)
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "HMM"
description "HIdden Markov Model"

\end_inset

 tagger taking keywords as its input.
 It uses the List-Viterbi 
\begin_inset CommandInset citation
LatexCommand citep
key "list_viterbi_1994"

\end_inset

 algorithm to produce the top-k most probable tagging sequences (where tags
 represent the 
\begin_inset Quotes eld
\end_inset

meaning
\begin_inset Quotes erd
\end_inset

 of each keyword).
 This is interpreted as SQL queries and presented to the users.
 The HMM is first initialized through the supervised training, but even
 if no training data is available, the initial HMM probability distributions
 can be estimated through a number of heuristic rules (e.g.
 promoting related tags).
 Later, user's feedback can be used for supervised training, while even
 the keyword queries itself can serve for unsupervised training 
\begin_inset CommandInset citation
LatexCommand citep
key "keymantic_list_viterbi_training_rota2011"

\end_inset

.
 According to 
\begin_inset CommandInset citation
LatexCommand citep
key "bergamaschi2011hidden"

\end_inset

 the accuracy of the two systems didn't differ much
\begin_inset Marginal
status open

\begin_layout Plain Layout

\color blue
\lang british
but they mentioned a better evaluation may be needed...
\end_layout

\end_inset

.
\begin_inset Marginal
status open

\begin_layout Plain Layout

\series bold
\lang british
also mention: NL querying over services
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Section
Future work
\end_layout

\begin_layout Standard
Terminology
\end_layout

\begin_layout Standard
Data Virtualization...
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Section*
References
\end_layout

\begin_layout Standard

\lang british
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "refs"
options "iopart-num"

\end_inset


\end_layout

\end_body
\end_document
